import{R as I,s as j}from"./index-Bny84ZkB.js";const w=e=>{let r;const t=new Set,a=(c,S)=>{const h=typeof c=="function"?c(r):c;if(!Object.is(h,r)){const f=r;r=S??(typeof h!="object"||h===null)?h:Object.assign({},r,h),t.forEach(d=>d(r,f))}},o=()=>r,u={setState:a,getState:o,getInitialState:()=>l,subscribe:c=>(t.add(c),()=>t.delete(c))},l=r=e(a,o,u);return u},C=e=>e?w(e):w,E=e=>e;function x(e,r=E){const t=I.useSyncExternalStore(e.subscribe,()=>r(e.getState()),()=>r(e.getInitialState()));return I.useDebugValue(t),t}const D=e=>{const r=C(e),t=a=>x(r,a);return Object.assign(t,r),t},_=e=>D,F=async(e,r)=>{const{data:t,error:a}=await j.from(e).select().eq("profileID",r);if(a)throw a;return t};function J(e,r){let t;try{t=e()}catch{return}return{getItem:o=>{var s;const m=l=>l===null?null:JSON.parse(l,void 0),u=(s=t.getItem(o))!=null?s:null;return u instanceof Promise?u.then(m):m(u)},setItem:(o,s)=>t.setItem(o,JSON.stringify(s,void 0)),removeItem:o=>t.removeItem(o)}}const p=e=>r=>{try{const t=e(r);return t instanceof Promise?t:{then(a){return p(a)(t)},catch(a){return this}}}catch(t){return{then(a){return this},catch(a){return p(a)(t)}}}},N=(e,r)=>(t,a,o)=>{let s={storage:J(()=>localStorage),partialize:n=>n,version:0,merge:(n,v)=>({...v,...n}),...r},m=!1;const u=new Set,l=new Set;let c=s.storage;if(!c)return e((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),t(...n)},a,o);const S=()=>{const n=s.partialize({...a()});return c.setItem(s.name,{state:n,version:s.version})},h=o.setState;o.setState=(n,v)=>{h(n,v),S()};const f=e((...n)=>{t(...n),S()},a,o);o.getInitialState=()=>f;let d;const b=()=>{var n,v;if(!c)return;m=!1,u.forEach(i=>{var g;return i((g=a())!=null?g:f)});const y=((v=s.onRehydrateStorage)==null?void 0:v.call(s,(n=a())!=null?n:f))||void 0;return p(c.getItem.bind(c))(s.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==s.version){if(s.migrate)return[!0,s.migrate(i.state,i.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,i.state];return[!1,void 0]}).then(i=>{var g;const[O,R]=i;if(d=s.merge(R,(g=a())!=null?g:f),t(d,!0),O)return S()}).then(()=>{y==null||y(d,void 0),d=a(),m=!0,l.forEach(i=>i(d))}).catch(i=>{y==null||y(void 0,i)})};return o.persist={setOptions:n=>{s={...s,...n},n.storage&&(c=n.storage)},clearStorage:()=>{c==null||c.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>b(),hasHydrated:()=>m,onHydrate:n=>(u.add(n),()=>{u.delete(n)}),onFinishHydration:n=>(l.add(n),()=>{l.delete(n)})},s.skipHydration||b(),d||f},H=N,L=_()(H(e=>({characters:[],setCharacters:async r=>{const t=await F("characters",r);e({characters:t})}}),{name:"characters"})),P=_()(H(e=>({character:{},setCharacter:async r=>{e({character:r})}}),{name:"character"}));export{L as a,P as u};
